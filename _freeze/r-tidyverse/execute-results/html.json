{
  "hash": "dec04d43b8056dd26c5124364c2d0934",
  "result": {
    "markdown": "---\ntitle: Introduction to R and the Tidyverse\nauthor: Clemens Schmid\nformat:\n  html:\n    link-external-icon: true\n    link-external-newwindow: true\neditor_options: \n  chunk_output_type: console\nbibliography: assets/references/chapters/r-tidyverse/references.bib\n---\n\n\n::: callout-note\nThis session is typically ran held in parallel to the Introduction to Python and Pandas. Participants of the summer schools chose which to attend based on their prior experience. We recommend this session if you have no experience with neither R nor Python.\n:::\n\n::: callout-tip\nFor this chapter's exercises, if not already performed, you will need to create the [conda environment](before-you-start.qmd#creating-a-conda-environment) from the `yml` file in the following [link](https://github.com/SPAAM-community/intro-to-ancient-metagenomics-book/raw/main/assets/envs/r-tidyverse.yml) (use `wget`, or right click and save as to download), and once created, activate the environment with:\n\n``` bash\nconda activate r-tidyverse\n```\n\nTo download the data for this chapter, please download following archive with, extract the tar, and change into the directory.\n\nFor example\n\n```bash\nwget https://www.dropbox.com/s/61zy5uadsatxz7y/r-tidyverse.tar.gz -P /<PATH>/<TO>/<SOMEWHERE_TO_STORE>/\ntar -xzf r-tidyverse.tar.gz\ncd r-tidyverse\n```\n:::\n\n\n::: {.cell}\n\n:::\n\n\n## The working environment\n\n### R, RStudio, the tidyverse and penguins\n\nR [@RCoreTeam2023] is a fully featured programming language, but it excels as an environment for (statistical) data analysis (<https://www.r-project.org>)\nRStudio [@RstudioTeam] is an integrated development environment (IDE) for R (and other languages) (<https://www.rstudio.com/products/rstudio>)\n\nThe tidyverse [@Wickham2019-ot] is a powerful collection of R packages with well-designed and consistent interfaces for the main steps of data analysis: loading, transforming and plotting data (<https://www.tidyverse.org>). This tutorial works with tidyverse ~v2.0. We will learn about the packages `readr`, `tibble`, `ggplot2`, `dplyr`, `magrittr` and `tidyr`. `forcats` will be briefly mentioned, but `purrr` and `stringr` are left out. \n\nThe `palmerpenguins` package [@Horst2020] provides a neat example dataset to learn data exploration and visualization in R (<https://allisonhorst.github.io/palmerpenguins>)\n\n::: {.callout-note title=\"Instructions for running this chapter without conda\" collapse=true}\n\nIf you wish to follow this chapter without installing conda, you can recreate the conda environment and data generation by running the following steps.\n\n1. Install R and RStudio for your operating system according to one of the many instructions online (e.g. [here](https://www.r-bloggers.com/2022/01/how-to-install-and-update-r-and-rstudio))\n2. Download the .qmd file underlying this webpage [here](https://github.com/SPAAM-community/intro-to-ancient-metagenomics-book/blob/main/r-tidyverse.qmd) and copy it to a new directory\n3. Open RStudio and create a new project in this directory with `File` -> `New Project...` -> `Existing directory`\n4. Open this very file from the RStudio project, so that you can easily follow along\n5. Run the `Environment preparation code` code to install necessary R package dependencies and prepare the required data used below\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# installing necessary R packages\ninstall.packages(c(\"tidyverse\", \"palmerpenguins\"))\n\n# preparing data\n# (at the end of this tutorial\n# you will understand this code)\nlibrary(magrittr)\nset.seed(5678)\n\npeng_prepped <- palmerpenguins::penguins %>%\n    dplyr::filter(\n        !dplyr::if_any(\n            .cols = tidyselect::everything(),\n            .fns = is.na\n        )\n    ) %>%\n    tibble::add_column(., id = 1:nrow(.), .before = \"species\")\n\npeng_prepped %>%\n    dplyr::slice_sample(n = 300) %>%\n    dplyr::arrange(id) %>%\n    dplyr::select(-bill_length_mm, -bill_depth_mm) %>%\n    readr::write_csv(\"penguins.csv\")\n\npeng_prepped %>%\n    dplyr::slice_sample(n = 300) %>%\n    dplyr::arrange(id) %>%\n    dplyr::select(id, bill_length_mm, bill_depth_mm) %>%\n    readr::write_csv(\"penguin_bills.csv\")\n```\n:::\n\n\n:::\n\nTo load RStudio from within your `conda` environment, please run\n\n```bash\nrstudio\n```\n\nAnd the RStudio window will open.\n\n## Loading data into tibbles\n\n### Reading data with readr\n\nWith R we usually operate on data in our computer's memory.\nThe tidyverse provides the package `readr` to read data from text files into the memory.\n`readr` can read from our file system or the internet.\nIt provides functions to read data in almost any (text) format:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadr::read_csv() # .csv files -> see penguins.csv\nreadr::read_tsv() # .tsv files\nreadr::read_delim() # tabular files with an arbitrary separator\nreadr::read_fwf() # fixed width files\nreadr::read_lines() # read linewise to parse yourself\n```\n:::\n\n\n### How does the interface of `read_csv` work?\n\nWe can learn more about an R function with the `?` operator.\n\nTo open a help file for a specific function run `?<function_name>` (e.g. `?readr::read_csv`) in the R console.\n`readr::read_csv` has many options to specify how to read a text file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(\n  file,                      # The path to the file we want to read\n  col_names = TRUE,          # Are there column names?\n  col_types = NULL,          # Which types do the columns have? NULL -> auto\n  locale = default_locale(), # How is information encoded in this file?\n  na = c(\"\", \"NA\"),          # Which values mean \"no data\"\n  trim_ws = TRUE,            # Should superfluous white-spaces be removed?\n  skip = 0,                  # Skip X lines at the beginning of the file\n  n_max = Inf,               # Only read X lines\n  skip_empty_rows = TRUE,    # Should empty lines be ignored? \n  comment = \"\",              # Should comment lines be ignored?\n  name_repair = \"unique\",    # How should \"broken\" column names be fixed\n  ...\n)\n```\n:::\n\n\n### What does `readr` produce? The `tibble`!\n\nTo read a .csv file (here `\"penguins.csv\"`) into a variable (here `peng_auto`) run.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng_auto <- readr::read_csv(\"penguins.csv\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\nRows: 300 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): species, island, sex\ndbl (4): id, flipper_length_mm, body_mass_g, year\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n`readr` first prints some information on the number and type of rows and columns it discovered in the file.\n\nIt automatically detects column types -- but you can also define them manually.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng <- readr::read_csv(\n  \"penguins.csv\",\n  col_types = \"iccddcc\" # this string encodes the desired types for each column\n)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nIt then returns an in-memory representation of this data, a `tibble`.\n\nA `tibble` is a \"data frame\", a tabular data structure with rows and columns.\nUnlike a simple array, each column can have another data type.\n\n### How to look at a `tibble`?\n\nTyping the name of any object into the R console will print an overview to the console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 7\n      id species island    flipper_length_mm body_mass_g sex    year \n   <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr>\n 1     1 Adelie  Torgersen               181        3750 male   2007 \n 2     2 Adelie  Torgersen               186        3800 female 2007 \n 3     4 Adelie  Torgersen               193        3450 female 2007 \n 4     5 Adelie  Torgersen               190        3650 male   2007 \n 5     6 Adelie  Torgersen               181        3625 female 2007 \n 6     7 Adelie  Torgersen               195        4675 male   2007 \n 7     9 Adelie  Torgersen               191        3800 male   2007 \n 8    10 Adelie  Torgersen               198        4400 male   2007 \n 9    11 Adelie  Torgersen               185        3700 female 2007 \n10    12 Adelie  Torgersen               195        3450 female 2007 \n# ℹ 290 more rows\n```\n:::\n:::\n\n\nBut there are various other ways to inspect the content of a `tibble` \n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(peng) # a structural overview of an R object\nsummary(peng) # a human-readable summary of an R object\nView(peng) # open RStudio's interactive data browser\n```\n:::\n\n\n## Plotting data in `tibble`s\n\n### `ggplot2` and the \"grammar of graphics\"\n\nTo understand and present data, we usually have to visualize it.\n\n`ggplot2` is an R package that offers an unusual, but powerful and logical interface for this task [@Wickham2016]. The following example describes a stacked bar chart.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2) # Loading a library to use its functions without ::\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot( # Every plot starts with a call to the ggplot() function\n    data = peng # This function can also take the input tibble\n) + # The plot consists of individual functions linked with \"+\"\n    geom_bar( # \"geoms\" define the plot layers we want to draw\n        mapping = aes( # The aes() function maps variables to visual properties\n            x = island, # publication_year -> x-axis\n            fill = species # community_type   -> fill color\n        )\n    )\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nA `geom_*` combines data (here `peng`), a geometry (here vertical, stacked bars) and a statistical transformation (here counting the number of penguins per island and species). `ggplot2` features many such geoms: A good overview is provided by this cheatsheet: [https://rstudio.github.io/cheatsheets/html/data-visualization.html](https://rstudio.github.io/cheatsheets/html/data-visualization.html).\n\nBeyond `geom`s, a ggplot plot can be further specified with (among others) `scale`s, `facet`s and `theme`s.\n\n### `scale`s control the behaviour of visual elements\n\nHere is another plot to demonstrate this: Boxplots of penguin weight per species.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng) +\n    geom_boxplot(aes(x = species, y = body_mass_g))\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nLet's assume we had some extreme outliers in this dataset. To simulate this, we replace some random weights with extreme values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1234) # we set a seed for reproducible randomness\npeng_out <- peng\npeng_out$body_mass_g[sample(1:nrow(peng_out), 10)] <- 50000 + 50000 * runif(10)\n```\n:::\n\n\nNow we plot the dataset with these \"outliers\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng_out) +\n    geom_boxplot(aes(x = species, y = body_mass_g))\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\nThis is not well readable, because the extreme outliers dictate the scale of the y-axis. A 50+kg penguin is a scary thought and we would probably remove these outliers, but let's assume they are valid observation we want to include in the plot.\n\nTo mitigate this issue we can change the **scale** of different visual elements - e.g. the y-axis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng_out) +\n    geom_boxplot(aes(x = species, y = body_mass_g)) +\n    scale_y_log10() # adding the log-scale improves readability\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\nWe will now go back to the normal dataset without the artificial outliers.\n\n### Colour `scale`s\n\n(Fill) colour is a visual element of a plot and its scaling can be adjusted as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng) +\n    geom_boxplot(aes(x = species, y = body_mass_g, fill = species)) +\n    scale_fill_viridis_d(option = \"C\")\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\nWe use the `scale_*` function to select one of the visually appealing (and robust to colourblindness) viridis colour palettes ([https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html)).\n\n### More variables! Defining plot matrices via `facet`s\n\nIn the previous example we didn't add additional information with the fill colour, as the plot already distinguished by species on the x-axis.\n\nWe can instead use colour to encode more information, for example by mapping the variable sex to it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng) +\n    geom_boxplot(aes(x = species, y = body_mass_g, fill = sex))\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nAnother way to visualize more variables in one plot is to split the plot by categories into **facets**, so sub-plots per category.\n\nHere we split by sex, which is already mapped to the fill colour.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng) +\n    geom_boxplot(aes(x = species, y = body_mass_g, fill = sex)) +\n    facet_wrap(~sex)\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nThe fill colour is therefore free again to show yet another variable, for example the year a given penguin was examined.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng) +\n    geom_boxplot(aes(x = species, y = body_mass_g, fill = year)) +\n    facet_wrap(~sex)\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n### Setting purely aesthetic settings with `theme`\n\nAesthetic changes can be applied as part of the `theme`, which allows for very detailed configuration (see `?theme`).\n\nHere we rotate the x-axis labels by 45°, which often helps to resolve overplotting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng) +\n    geom_boxplot(aes(x = species, y = body_mass_g, fill = year)) +\n    facet_wrap(~sex) +\n    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1))\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n### Ordering elements in a plot with `factors`\n\nR supports defining ordinal data with `factor`s. This can be used to set the order of elements in a plot, e.g. the order of bars in a bar chart. \n\nWe do not cover `factor`s beyond the following example here, although the tidyverse includes a package (`forcats`) specifically for that purpose.\n\nElements based on `character` columns are generally ordered alphabetically.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng) +\n    geom_bar(aes(x = species)) # bars are alphabetically ordered\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nWith `forcats::fct_reorder` we can transform an input vector to a `factor`, ordered by a summary statistic (even based on another vector).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng2 <- peng\npeng2$species_ordered <- forcats::fct_reorder(\n  peng2$species,\n  peng2$species, length\n)\n```\n:::\n\n\nWith this change, the plot will be ordered according to the intrinsic order defined for `species_ordered`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(peng2) +\n    geom_bar(aes(x = species_ordered)) # bars are ordered by size\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n### Exercise\n\n1. Look at the `mtcars` dataset and read up on the meaning of its variables with the help operator `?`. `mtcars` is a test dataset integrated in R and can be accessed by typing `mtcars` in the console\n\n2. Visualize the relationship between *Gross horsepower* and *1/4 mile time*\n\n\n::: {.cell}\n\n:::\n\n\n3. Integrate the *Number of cylinders* into your plot as an additional variable\n\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip title=\"Possible solutions\" collapse=true}\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?mtcars\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mtcars) +\n    geom_point(aes(x = hp, y = qsec))\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mtcars) +\n    geom_point(aes(x = hp, y = qsec, color = as.factor(cyl)))\n```\n\n::: {.cell-output-display}\n![](r-tidyverse_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Conditional queries on tibbles\n\n### Selecting columns and filtering rows with `select` and `filter`\n\n\n::: {.cell}\n\n:::\n\n\nThe `dplyr` package includes powerful functions to subset data in tibbles based on conditions. `dplyr::select` allows to select columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::select(peng, id, flipper_length_mm) # reduce tibble to two columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 2\n     id flipper_length_mm\n  <int>             <dbl>\n1     1               181\n2     2               186\n3     4               193\n4     5               190\n5     6               181\n# ℹ 295 more rows\n```\n:::\n\n```{.r .cell-code}\ndplyr::select(peng, -island, -flipper_length_mm) # remove two columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 5\n     id species body_mass_g sex    year \n  <int> <chr>         <dbl> <chr>  <chr>\n1     1 Adelie         3750 male   2007 \n2     2 Adelie         3800 female 2007 \n3     4 Adelie         3450 female 2007 \n4     5 Adelie         3650 male   2007 \n5     6 Adelie         3625 female 2007 \n# ℹ 295 more rows\n```\n:::\n:::\n\n\n`dplyr::filter` allows for conditional filtering of rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::filter(peng, year == 2007) # penguins examined in 2007\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 93 × 7\n     id species island    flipper_length_mm body_mass_g sex    year \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr>\n1     1 Adelie  Torgersen               181        3750 male   2007 \n2     2 Adelie  Torgersen               186        3800 female 2007 \n3     4 Adelie  Torgersen               193        3450 female 2007 \n4     5 Adelie  Torgersen               190        3650 male   2007 \n5     6 Adelie  Torgersen               181        3625 female 2007 \n# ℹ 88 more rows\n```\n:::\n\n```{.r .cell-code}\ndplyr::filter(peng, year == 2007 |\n    year == 2009) # penguins examined in 2007 OR 2009\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 198 × 7\n     id species island    flipper_length_mm body_mass_g sex    year \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr>\n1     1 Adelie  Torgersen               181        3750 male   2007 \n2     2 Adelie  Torgersen               186        3800 female 2007 \n3     4 Adelie  Torgersen               193        3450 female 2007 \n4     5 Adelie  Torgersen               190        3650 male   2007 \n5     6 Adelie  Torgersen               181        3625 female 2007 \n# ℹ 193 more rows\n```\n:::\n\n```{.r .cell-code}\ndplyr::filter(\n    peng, # an alternative way to express\n    year %in% c(2007, 2009)\n) # OR with the match operator \"%in%\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 198 × 7\n     id species island    flipper_length_mm body_mass_g sex    year \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr>\n1     1 Adelie  Torgersen               181        3750 male   2007 \n2     2 Adelie  Torgersen               186        3800 female 2007 \n3     4 Adelie  Torgersen               193        3450 female 2007 \n4     5 Adelie  Torgersen               190        3650 male   2007 \n5     6 Adelie  Torgersen               181        3625 female 2007 \n# ℹ 193 more rows\n```\n:::\n\n```{.r .cell-code}\ndplyr::filter(peng, species == \"Adelie\" &\n    body_mass_g >= 4000) # Adelie penguins heavier than 4kg\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 29 × 7\n     id species island    flipper_length_mm body_mass_g sex   year \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr> <chr>\n1     7 Adelie  Torgersen               195        4675 male  2007 \n2    10 Adelie  Torgersen               198        4400 male  2007 \n3    13 Adelie  Torgersen               197        4500 male  2007 \n4    31 Adelie  Dream                   196        4150 male  2007 \n5    39 Adelie  Dream                   196        4400 male  2007 \n# ℹ 24 more rows\n```\n:::\n:::\n\n\n### Chaining functions together with the pipe `%>%`\n\nA core feature of the tidyverse is the pipe `%>%` in the `magrittr` package. This 'infix' operator allows to chain data and operations for concise and clear data analysis syntax.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magrittr)\npeng %>% dplyr::filter(year == 2007)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 93 × 7\n     id species island    flipper_length_mm body_mass_g sex    year \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr>\n1     1 Adelie  Torgersen               181        3750 male   2007 \n2     2 Adelie  Torgersen               186        3800 female 2007 \n3     4 Adelie  Torgersen               193        3450 female 2007 \n4     5 Adelie  Torgersen               190        3650 male   2007 \n5     6 Adelie  Torgersen               181        3625 female 2007 \n# ℹ 88 more rows\n```\n:::\n:::\n\n\nIt forwards the LHS (left-hand side) as the first argument of the function appearing on the RHS (right-hand side), which enables sequences of functions (\"tidyverse style\").\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>%\n    dplyr::select(id, species, body_mass_g) %>%\n    dplyr::filter(species == \"Adelie\" & body_mass_g >= 4000) %>%\n    nrow() # count the resulting rows\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] 29\n```\n:::\n:::\n\n\n`magrittr` also offers some more operators, among which the extraction `%$%` is particularly useful to easily extract individual variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>%\n    dplyr::filter(island == \"Biscoe\") %$%\n    species %>% # extract the species column as a vector\n    unique() # get the unique elements of said vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] \"Adelie\" \"Gentoo\"\n```\n:::\n:::\n\n\nHere we already use the base R summary function `unique`.\n\n### Summary statistics in `base` R\n\nSummarising and counting data is indispensable and R offers all basic operations you would expect in its `base` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchinstraps_weights <- peng %>%\n    dplyr::filter(species == \"Chinstrap\") %$%\n    body_mass_g\n\nlength(chinstraps_weights) # length/size of a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] 63\n```\n:::\n\n```{.r .cell-code}\nunique(chinstraps_weights) # unique elements of a vector\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n [1] 3500 3900 3650 3525 3725 3950 3250 3750 4150 3700 3800 3775 4050 3300 3450\n[16] 4400 3400 2900 4550 3200 4300 3350 4100 3600 3850 4800 2700 4500 3550 3675\n[31] 4450 3325 4000\n```\n:::\n\n```{.r .cell-code}\nmin(chinstraps_weights) # minimum\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] 2700\n```\n:::\n\n```{.r .cell-code}\nmax(chinstraps_weights) # maximum\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] 4800\n```\n:::\n\n```{.r .cell-code}\nmean(chinstraps_weights) # mean\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] 3751.19\n```\n:::\n\n```{.r .cell-code}\nmedian(chinstraps_weights) # median\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] 3725\n```\n:::\n\n```{.r .cell-code}\nvar(chinstraps_weights) # variance\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] 153032.8\n```\n:::\n\n```{.r .cell-code}\nsd(chinstraps_weights) # standard deviation\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] 391.1941\n```\n:::\n\n```{.r .cell-code}\nquantile(chinstraps_weights, probs = 0.75) # quantiles for the given probabilities\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n 75% \n3975 \n```\n:::\n:::\n\n\nMany of these functions can ignore missing values with an option `na.rm = TRUE`.\n\n### Group-wise summaries with `group_by` and `summarise`\n\nThese summary statistics are particular useful when applied to conditional subsets of a dataset.\n\n`dplyr` allows such summary operations with a combination of the functions `group_by` and `summarise`, where the former tags a `tibble` with categories based on its variables and the latter reduces it to these groups while simultanously creating new columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>%\n    dplyr::group_by(species) %>% # group the tibble by the material column\n    dplyr::summarise(\n        min_weight = min(body_mass_g), # new col: min weight for each group\n        median_weight = median(body_mass_g), # new col: median weight for each group\n        max_weight = max(body_mass_g) # new col: max weight for each group\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 3 × 4\n  species   min_weight median_weight max_weight\n  <chr>          <dbl>         <dbl>      <dbl>\n1 Adelie          2850          3650       4775\n2 Chinstrap       2700          3725       4800\n3 Gentoo          3950          5050       6300\n```\n:::\n:::\n\n\nGrouping can also be applied across multiple columns at once.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>%\n    dplyr::group_by(species, year) %>% # group by species and year\n    dplyr::summarise(\n        n = dplyr::n(), # a new column: number of penguins for each group\n        .groups = \"drop\" # drop the grouping after this summary operation\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 9 × 3\n  species   year      n\n  <chr>     <chr> <int>\n1 Adelie    2007     38\n2 Adelie    2008     45\n3 Adelie    2009     43\n4 Chinstrap 2007     23\n5 Chinstrap 2008     18\n# ℹ 4 more rows\n```\n:::\n:::\n\n\nIf we group by more than one variable, then `summarise` will not entirely remove the group tagging when generating the result dataset. We can force this with `.groups = \"drop\"` to avoid undesired behaviour with this dataset later on.\n\n### Sorting and slicing tibbles with `arrange` and `slice`\n\n`dplyr` allows to `arrange` tibbles by one or multiple columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>% dplyr::arrange(sex) # sort by sex\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 7\n     id species island    flipper_length_mm body_mass_g sex    year \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr>\n1     2 Adelie  Torgersen               186        3800 female 2007 \n2     4 Adelie  Torgersen               193        3450 female 2007 \n3     6 Adelie  Torgersen               181        3625 female 2007 \n4    11 Adelie  Torgersen               185        3700 female 2007 \n5    12 Adelie  Torgersen               195        3450 female 2007 \n# ℹ 295 more rows\n```\n:::\n\n```{.r .cell-code}\npeng %>% dplyr::arrange(sex, body_mass_g) # sort by sex and weight\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 7\n     id species   island    flipper_length_mm body_mass_g sex    year \n  <int> <chr>     <chr>                 <dbl>       <dbl> <chr>  <chr>\n1   304 Chinstrap Dream                   192        2700 female 2008 \n2    53 Adelie    Biscoe                  181        2850 female 2008 \n3    59 Adelie    Biscoe                  184        2850 female 2008 \n4    49 Adelie    Biscoe                  187        2900 female 2008 \n5   111 Adelie    Torgersen               188        2900 female 2009 \n# ℹ 295 more rows\n```\n:::\n\n```{.r .cell-code}\npeng %>% dplyr::arrange(dplyr::desc(body_mass_g)) # sort descending\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 7\n     id species island flipper_length_mm body_mass_g sex   year \n  <int> <chr>   <chr>              <dbl>       <dbl> <chr> <chr>\n1   164 Gentoo  Biscoe               221        6300 male  2007 \n2   179 Gentoo  Biscoe               230        6050 male  2007 \n3   260 Gentoo  Biscoe               222        6000 male  2009 \n4   224 Gentoo  Biscoe               223        5950 male  2008 \n5   160 Gentoo  Biscoe               213        5850 male  2007 \n# ℹ 295 more rows\n```\n:::\n:::\n\n\nSorting also works within groups and can be paired with `slice` to extract extreme values per group.\n\nHere we extract the heaviest individuals per species.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>%\n    dplyr::group_by(species) %>% # group by species\n    dplyr::arrange(dplyr::desc(body_mass_g)) %>% # sort by weight within (!) groups\n    dplyr::slice_head(n = 3) %>% # keep the first three penguins per group\n    dplyr::ungroup() # remove the still lingering grouping\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 9 × 7\n     id species   island    flipper_length_mm body_mass_g sex   year \n  <int> <chr>     <chr>                 <dbl>       <dbl> <chr> <chr>\n1   104 Adelie    Biscoe                  197        4775 male  2009 \n2    96 Adelie    Biscoe                  203        4725 male  2009 \n3    76 Adelie    Torgersen               196        4700 male  2008 \n4   303 Chinstrap Dream                   210        4800 male  2008 \n5   295 Chinstrap Dream                   205        4550 male  2008 \n# ℹ 4 more rows\n```\n:::\n:::\n\n\nSlicing is also the relevant operation to take random samples from the observations in a `tibble`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>% dplyr::slice_sample(n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 10 × 7\n     id species island flipper_length_mm body_mass_g sex    year \n  <int> <chr>   <chr>              <dbl>       <dbl> <chr>  <chr>\n1    47 Adelie  Biscoe               190        3450 female 2008 \n2   239 Gentoo  Biscoe               214        4850 female 2009 \n3   221 Gentoo  Biscoe               209        4600 female 2008 \n4   104 Adelie  Biscoe               197        4775 male   2009 \n5   138 Adelie  Dream                190        3725 male   2009 \n# ℹ 5 more rows\n```\n:::\n:::\n\n\n### Exercise\n\nFor this exercise we once more go back to the `mtcars` dataset. See `?mtcars` for details\n\n1. Determine the number of cars with four *forward gears* (`gear`) in the `mtcars` dataset\n\n\n::: {.cell}\n\n:::\n\n\n2. Determine the mean *1/4 mile time* (`qsec`) per *Number of cylinders* (`cyl`) group\n\n\n::: {.cell}\n\n:::\n\n\n3. Identify the least efficient cars for both *transmission types* (`am`)\n\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip title=\"Possible solutions\" collapse=true}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n    dplyr::filter(gear == 4) %>%\n    nrow()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] 12\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n    dplyr::group_by(cyl) %>%\n    dplyr::summarise(\n        qsec_mean = mean(qsec)\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 3 × 2\n    cyl qsec_mean\n  <dbl>     <dbl>\n1     4      19.1\n2     6      18.0\n3     8      16.8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars2 <- tibble::rownames_to_column(mtcars, var = \"car\")\nmtcars2 %>%\n    dplyr::group_by(am) %>%\n    dplyr::arrange(mpg) %>%\n    dplyr::slice_head() %$%\n    car\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n[1] \"Cadillac Fleetwood\" \"Maserati Bora\"     \n```\n:::\n:::\n\n\n:::\n\n## Transforming and manipulating tibbles\n\n### Renaming and reordering columns with `rename` and `relocate`\n\nColumns in tibbles can be renamed with `dplyr::rename`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>% dplyr::rename(penguin_name = id) # rename a column\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 7\n  penguin_name species island    flipper_length_mm body_mass_g sex    year \n         <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr>\n1            1 Adelie  Torgersen               181        3750 male   2007 \n2            2 Adelie  Torgersen               186        3800 female 2007 \n3            4 Adelie  Torgersen               193        3450 female 2007 \n4            5 Adelie  Torgersen               190        3650 male   2007 \n5            6 Adelie  Torgersen               181        3625 female 2007 \n# ℹ 295 more rows\n```\n:::\n:::\n\n\nAnd with `dplyr::relocate` they can be reordered.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>% dplyr::relocate(year, .before = species) # reorder columns\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 7\n     id year  species island    flipper_length_mm body_mass_g sex   \n  <int> <chr> <chr>   <chr>                 <dbl>       <dbl> <chr> \n1     1 2007  Adelie  Torgersen               181        3750 male  \n2     2 2007  Adelie  Torgersen               186        3800 female\n3     4 2007  Adelie  Torgersen               193        3450 female\n4     5 2007  Adelie  Torgersen               190        3650 male  \n5     6 2007  Adelie  Torgersen               181        3625 female\n# ℹ 295 more rows\n```\n:::\n:::\n\n\nAdding columns to tibbles with `mutate` and `transmute`.\n\nA common application of data manipulation is adding new, derived columns, that combine or modify the information in the already available columns. `dplyr` offers this core feature with the `mutate` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>%\n    dplyr::mutate( # add a column that\n        kg = body_mass_g / 1000 # manipulates an existing column\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 8\n     id species island    flipper_length_mm body_mass_g sex    year     kg\n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr> <dbl>\n1     1 Adelie  Torgersen               181        3750 male   2007   3.75\n2     2 Adelie  Torgersen               186        3800 female 2007   3.8 \n3     4 Adelie  Torgersen               193        3450 female 2007   3.45\n4     5 Adelie  Torgersen               190        3650 male   2007   3.65\n5     6 Adelie  Torgersen               181        3625 female 2007   3.62\n# ℹ 295 more rows\n```\n:::\n:::\n\n\n`dplyr::transmute` has the same interface as `dplyr::mutate`, but it removes all columns except for the newly created ones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>%\n  dplyr::transmute(\n    id = paste(\"Penguin Nr.\", id), # overwrite this column\n    flipper_length_mm               # select this column\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 2\n  id            flipper_length_mm\n  <chr>                     <dbl>\n1 Penguin Nr. 1               181\n2 Penguin Nr. 2               186\n3 Penguin Nr. 4               193\n4 Penguin Nr. 5               190\n5 Penguin Nr. 6               181\n# ℹ 295 more rows\n```\n:::\n:::\n\n\n`tibble::add_column` behaves as `dplyr::mutate`, but gives more control over column position.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>% tibble::add_column(\n  flipper_length_cm = .$flipper_length_mm/10, # not the . representing the LHS of the pipe\n  .after = \"flipper_length_mm\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 8\n     id species island    flipper_length_mm flipper_length_cm body_mass_g sex   \n  <int> <chr>   <chr>                 <dbl>             <dbl>       <dbl> <chr> \n1     1 Adelie  Torgersen               181              18.1        3750 male  \n2     2 Adelie  Torgersen               186              18.6        3800 female\n3     4 Adelie  Torgersen               193              19.3        3450 female\n4     5 Adelie  Torgersen               190              19          3650 male  \n5     6 Adelie  Torgersen               181              18.1        3625 female\n# ℹ 295 more rows\n# ℹ 1 more variable: year <chr>\n```\n:::\n:::\n\n\n`dplyr::mutate` can also be combined with `dplyr::group_by` (instead of `dplyr::summarise`) to add information on a group level. This is relevant, when a value for an individual entity should be put into context of a group-wise summary statistic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>%\n    dplyr::group_by(species, sex, year) %>%\n    dplyr::mutate(\n        mean_weight = mean(body_mass_g, na.rm = T),\n        relation_to_mean = body_mass_g / mean_weight\n    ) %>%\n    dplyr::ungroup() %>%\n    dplyr::select(id, species, sex, year, relation_to_mean) %>%\n    # mutate does not remove rows, unlike summarise, so we use select\n    dplyr::arrange(dplyr::desc(relation_to_mean))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 5\n     id species   sex    year  relation_to_mean\n  <int> <chr>     <chr>  <chr>            <dbl>\n1   104 Adelie    male   2009              1.21\n2    96 Adelie    male   2009              1.20\n3   274 Chinstrap female 2007              1.17\n4     7 Adelie    male   2007              1.17\n5   303 Chinstrap male   2008              1.16\n# ℹ 295 more rows\n```\n:::\n:::\n\n\n### Conditional operations with `ifelse`, `case_when` and `case_match`\n\n`ifelse` allows to implement conditional `mutate` operations, that consider information from other columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>% dplyr::mutate(\n  weight = ifelse(\n    test = body_mass_g >= 4200, # is weight below or above mean weight?\n    yes = \"above mean\",\n    no = \"below mean\"\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 8\n     id species island    flipper_length_mm body_mass_g sex    year  weight    \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr> <chr>     \n1     1 Adelie  Torgersen               181        3750 male   2007  below mean\n2     2 Adelie  Torgersen               186        3800 female 2007  below mean\n3     4 Adelie  Torgersen               193        3450 female 2007  below mean\n4     5 Adelie  Torgersen               190        3650 male   2007  below mean\n5     6 Adelie  Torgersen               181        3625 female 2007  below mean\n# ℹ 295 more rows\n```\n:::\n:::\n\n\n`ifelse` gets cumbersome easily. `dplyr::case_when` is more readable and scales much better for this application.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>% dplyr::mutate(\n  weight = dplyr::case_when(\n    body_mass_g >= 4200 ~ \"above mean\", # the number of conditions is arbitrary\n    body_mass_g < 4200  ~ \"below mean\",\n    TRUE                ~ \"unknown\"     # TRUE catches all remaining cases\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 8\n     id species island    flipper_length_mm body_mass_g sex    year  weight    \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr> <chr>     \n1     1 Adelie  Torgersen               181        3750 male   2007  below mean\n2     2 Adelie  Torgersen               186        3800 female 2007  below mean\n3     4 Adelie  Torgersen               193        3450 female 2007  below mean\n4     5 Adelie  Torgersen               190        3650 male   2007  below mean\n5     6 Adelie  Torgersen               181        3625 female 2007  below mean\n# ℹ 295 more rows\n```\n:::\n:::\n\n\n`dplyr::case_match` is similar, but unlike `dplyr::case_when` it does not check logical expressions, but matches by value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npeng %>%\n    dplyr::mutate(\n        island_rating = dplyr::case_match(\n            island,\n            \"Torgersen\" ~ \"My favourite island\",\n            \"Biscoe\" ~ \"Overrated tourist trap\",\n            \"Dream\" ~ \"Lost my wallet there. 4/10\"\n        )\n    ) %>%\n    # here we use group_by+summarise only to show the result\n    dplyr::group_by(island, island_rating) %>%\n    dplyr::summarise(.groups = \"drop\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 3 × 2\n  island    island_rating             \n  <chr>     <chr>                     \n1 Biscoe    Overrated tourist trap    \n2 Dream     Lost my wallet there. 4/10\n3 Torgersen My favourite island       \n```\n:::\n:::\n\n\n### Switching between long and wide data with `pivot_longer` and `pivot_wider`\n\nTo simplify certain analysis or plotting operations data often has to be transformed from a **wide** to a **long** format or vice versa (@fig-rtidyverse-longtowide).\n\n![Graphical representation of converting a table from a wide format (first column are categories, e.g. species, first row are also categories e.g., samples, and counts are in cells after first row/column. Conversion from wide to long makes the long-format so that the first columnn still has categories, but the second column becomes the column-categories from the first row, and third column has values. Converting long format back to wider shows again first row and column as categories and cells as values).](assets/images/chapters/r-tidyverse/pivot_longer_wider.png){#fig-rtidyverse-longtowide height=150px}\n\n- A table in **wide** format has N key columns and N value columns.\n- A table in **long** format has N key columns, one descriptor column and one value column.\n\nHere is an example of a wide dataset. It features information about the number of cars sold per year per brand at a dealership.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncarsales <- tibble::tribble(\n    ~brand, ~`2014`, ~`2015`, ~`2016`, ~`2017`,\n    \"BMW\", 20, 25, 30, 45,\n    \"VW\", 67, 40, 120, 55\n)\ncarsales\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 2 × 5\n  brand `2014` `2015` `2016` `2017`\n  <chr>  <dbl>  <dbl>  <dbl>  <dbl>\n1 BMW       20     25     30     45\n2 VW        67     40    120     55\n```\n:::\n:::\n\n\nWide format data becomes a problem, when the columns are semantically identical. This dataset is in wide format and we can not easily plot it. We generally prefer data in long format, although it is more verbose with more duplication.\n\nTo transform this dataset to a long format, we can apply `tidyr::pivot_longer`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncarsales_long <- carsales %>% tidyr::pivot_longer(\n    cols = tidyselect::num_range(\n        \"\",\n        range = 2014:2017\n    ), # define a set of columns to transform\n    names_to = \"year\", # the name of the descriptor column we want\n    names_transform = as.integer, # a transformation function to apply to the names\n    values_to = \"sales\" # the name of the value column we want\n)\ncarsales_long\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 8 × 3\n  brand  year sales\n  <chr> <int> <dbl>\n1 BMW    2014    20\n2 BMW    2015    25\n3 BMW    2016    30\n4 BMW    2017    45\n5 VW     2014    67\n# ℹ 3 more rows\n```\n:::\n:::\n\n\nWide datasets are not always the wrong choice, for example for adjacency matrices to represent graphs, covariance matrices or other pairwise statistics.\nWhen data gets big, then wide formats can be significantly more efficient (e.g. for spatial data).\n\nSo transform data from long to wide, we can use `tidyr::pivot_wider`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncarsales_wide <- carsales_long %>% tidyr::pivot_wider(\n    id_cols = \"brand\", # the set of id columns that should not be changed\n    names_from = year, # the descriptor column with the names of the new columns\n    values_from = sales # the value column from which the values should be extracted\n)\ncarsales_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 2 × 5\n  brand `2014` `2015` `2016` `2017`\n  <chr>  <dbl>  <dbl>  <dbl>  <dbl>\n1 BMW       20     25     30     45\n2 VW        67     40    120     55\n```\n:::\n:::\n\n\n### Exercise\n\n1. Move the column `gear` to the first position of the mtcars dataset\n\n\n::: {.cell}\n\n:::\n\n\n2. Make a new dataset `mtcars2` with the column `mpg` and an additional column `am_v`, which encodes the *transmission type* (`am`) as either `\"manual\"` or `\"automatic\"`\n\n\n::: {.cell}\n\n:::\n\n\n3. Count the number of cars per *transmission type* (`am_v`) and *number of gears* (`gear`). Then transform the result to a wide format, with one column per *transmission type*.\n\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip title=\"Possible solutions\" collapse=true}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n    dplyr::relocate(gear, .before = mpg) %>%\n    tibble::as_tibble() # transforming the raw dataset for better printing\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 32 × 11\n   gear   mpg   cyl  disp    hp  drat    wt  qsec    vs    am  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1     4  21       6   160   110  3.9   2.62  16.5     0     1     4\n2     4  21       6   160   110  3.9   2.88  17.0     0     1     4\n3     4  22.8     4   108    93  3.85  2.32  18.6     1     1     1\n4     3  21.4     6   258   110  3.08  3.22  19.4     1     0     1\n5     3  18.7     8   360   175  3.15  3.44  17.0     0     0     2\n# ℹ 27 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars2 <- mtcars %>%\n    dplyr::mutate(\n        gear,\n        am_v = dplyr::case_match(\n            am,\n            0 ~ \"automatic\",\n            1 ~ \"manual\"\n        )\n    ) %>%\n    tibble::as_tibble()\nmtcars2\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 32 × 12\n    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb am_v     \n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <chr>    \n1  21       6   160   110  3.9   2.62  16.5     0     1     4     4 manual   \n2  21       6   160   110  3.9   2.88  17.0     0     1     4     4 manual   \n3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1 manual   \n4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1 automatic\n5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2 automatic\n# ℹ 27 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars2 %>%\n    dplyr::group_by(am_v, gear) %>%\n    dplyr::tally() %>% # dplyr::tally() is identical to\n    # dplyr::summarise(n = dplyr::n())\n    # it counts the number of entities in a group\n    tidyr::pivot_wider(\n        names_from = am_v,\n        values_from = n\n    )\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 3 × 3\n   gear automatic manual\n  <dbl>     <int>  <int>\n1     3        15     NA\n2     4         4      8\n3     5        NA      5\n```\n:::\n:::\n\n\n:::\n\n## Combining tibbles with join operations\n\n### Types of joins\n\nJoins combine two datasets x and y based on overlapping key columns.\n\nMutating joins add columns from one dataset to the other:\n\n  - Left join: Take observations from x and add fitting information from y.\n  - Right join: Take observations from y and add fitting information from x.\n  - Inner join: Join the overlapping observations from x and y.\n  - Full join: Join all observations from x and y, even if information is missing.\n\nFiltering joins remove observations from x based on their presence in y.\n\nTypes of filtering consist of: \n\n  - Semi join: Keep every observation in x that is in y.\n  - Anti join: Keep every observation in x that is not in y.\n\nThe following sections will introduce each join with an example.\n\nTo experiment with joins, we need a second dataset with complementary information. This new dataset contains additional variables for a subset of the penguins in our first dataset -- both datasets feature 300 penguins, but only with a partial overlap in individuals.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbills <- readr::read_csv(\"penguin_bills.csv\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 3\n     id bill_length_mm bill_depth_mm\n  <dbl>          <dbl>         <dbl>\n1     1           39.1          18.7\n2     2           39.5          17.4\n3     3           40.3          18  \n4     4           36.7          19.3\n5     5           39.3          20.6\n# ℹ 295 more rows\n```\n:::\n:::\n\n\n### Left join with `left_join`\n\nTake observations from x and add fitting information from y (@fig-rtidyverse-leftjoin).\n\n![Graphical representation of left join operation. Two tables with a shared first column (A B C, and A B D respectively) are merged together to have columns A B C D. As A and B have a one to one match of values, this remains the same in the joined table. The B column between the two have a different value on the third row, and thus is lost from the second table, retaining row 3 of the first table. Column D (from the second table) has an empty value on row three, as this row was not in row 3 of the second table that column D was derived from.](assets/images/chapters/r-tidyverse/left_join.png){height=150px #fig-rtidyverse-leftjoin} \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::left_join(\n  x = peng,  # 300 observations\n  y = bills, # 300 observations\n  by = \"id\"  # the key column by which to join\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 9\n     id species island  flipper_length_mm body_mass_g sex   year  bill_length_mm\n  <dbl> <chr>   <chr>               <dbl>       <dbl> <chr> <chr>          <dbl>\n1     1 Adelie  Torger…               181        3750 male  2007            39.1\n2     2 Adelie  Torger…               186        3800 fema… 2007            39.5\n3     4 Adelie  Torger…               193        3450 fema… 2007            36.7\n4     5 Adelie  Torger…               190        3650 male  2007            39.3\n5     6 Adelie  Torger…               181        3625 fema… 2007            38.9\n# ℹ 295 more rows\n# ℹ 1 more variable: bill_depth_mm <dbl>\n```\n:::\n:::\n\n\nLeft joins are the most common join operation: Add information from y to the main dataset x.\n\n### Right join with `right_join`\n\nTake observations from y and add fitting information from x (@fig-rtidyverse-rightjoin).\n\n![Graphical representation of right join operation. Two tables with a shared first column (A B C, and A B D respectively) are merged together to have columns A B C D. As A and B have a one to one match of values, this remains the same in the joined table. The B column between the two have a different value on the third row, and thus is lost from the first table, retaining row 3 of the second table. Column C (from the first table) has an empty value on row three, as this row was not in row 3 of the first table that column C was derived from.](assets/images/chapters/r-tidyverse/right_join.png){height=150px #fig-rtidyverse-rightjoin} \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::right_join(\n    x = peng, # 300 observations\n    y = bills, # 300 observations\n    by = \"id\"\n) %>% # we arrange by id to highlight the missing\n    dplyr::arrange(id) # observation in the peng dataset\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 300 × 9\n     id species island  flipper_length_mm body_mass_g sex   year  bill_length_mm\n  <dbl> <chr>   <chr>               <dbl>       <dbl> <chr> <chr>          <dbl>\n1     1 Adelie  Torger…               181        3750 male  2007            39.1\n2     2 Adelie  Torger…               186        3800 fema… 2007            39.5\n3     3 <NA>    <NA>                   NA          NA <NA>  <NA>            40.3\n4     4 Adelie  Torger…               193        3450 fema… 2007            36.7\n5     5 Adelie  Torger…               190        3650 male  2007            39.3\n# ℹ 295 more rows\n# ℹ 1 more variable: bill_depth_mm <dbl>\n```\n:::\n:::\n\n\nRight joins are almost identical to left joins -- only x and y have reversed roles.\n\n### Inner join with `inner_join`\n\nJoin the overlapping observations from x and y (@fig-rtidyverse-innerjoin).\n\n![Graphical representation of inner join operation. Two tables with a shared first column (A B C, and A B D respectively) are merged together to have columns A B C D. Only rows from both table that have exact matches on columns A and B are retained. The third rows from both tables that had a different value in column B are lost.](assets/images/chapters/r-tidyverse/inner_join.png){height=150px #fig-rtidyverse-innerjoin} \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::inner_join(\n  x = peng,  # 300 observations\n  y = bills, # 300 observations\n  by = \"id\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 275 × 9\n     id species island  flipper_length_mm body_mass_g sex   year  bill_length_mm\n  <dbl> <chr>   <chr>               <dbl>       <dbl> <chr> <chr>          <dbl>\n1     1 Adelie  Torger…               181        3750 male  2007            39.1\n2     2 Adelie  Torger…               186        3800 fema… 2007            39.5\n3     4 Adelie  Torger…               193        3450 fema… 2007            36.7\n4     5 Adelie  Torger…               190        3650 male  2007            39.3\n5     6 Adelie  Torger…               181        3625 fema… 2007            38.9\n# ℹ 270 more rows\n# ℹ 1 more variable: bill_depth_mm <dbl>\n```\n:::\n:::\n\n\nInner joins are a fast and easy way to check, to which degree two dataset overlap.\n\n### Full join with `full_join`\n\nJoin all observations from x and y, even if information is missing (@fig-rtidyverse-fulljoin).\n\n![Graphical representation of full join operation. Two tables with a shared first column (A B C, and A B D respectively) are merged together to have columns A B C D. All rows from both tables are retained, even though they do not share the same value on column B on both tables. The missing values for the two third rows (i.e., column C from the second table, and column D from the first table) are are filled with an empty cell indicated with `-`.](assets/images/chapters/r-tidyverse/inner_join.png){height=150px #fig-rtidyverse-fulljoin} \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::full_join(\n    x = peng, # 300 observations\n    y = bills, # 300 observations\n    by = \"id\"\n) %>% dplyr::arrange(id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 325 × 9\n     id species island  flipper_length_mm body_mass_g sex   year  bill_length_mm\n  <dbl> <chr>   <chr>               <dbl>       <dbl> <chr> <chr>          <dbl>\n1     1 Adelie  Torger…               181        3750 male  2007            39.1\n2     2 Adelie  Torger…               186        3800 fema… 2007            39.5\n3     3 <NA>    <NA>                   NA          NA <NA>  <NA>            40.3\n4     4 Adelie  Torger…               193        3450 fema… 2007            36.7\n5     5 Adelie  Torger…               190        3650 male  2007            39.3\n# ℹ 320 more rows\n# ℹ 1 more variable: bill_depth_mm <dbl>\n```\n:::\n:::\n\n\nFull joins allow to preserve every bit of information.\n\n### Semi join with `semi_join`\n\nKeep every observation in x that is in y (@fig-rtidyverse-semijoin).\n\n![Graphical representation of semi join operation. Two tables with a shared first column (A B C, and A B D respectively) are merged together to have only columns A B C. Only columns A B and C are retained in the joined table. Row three of both tables are not included as the column values in columns A and B do not match.](assets/images/chapters/r-tidyverse/semi_join.png){height=150px #fig-rtidyverse-semijoin} \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::semi_join(\n  x = peng,  # 300 observations\n  y = bills, # 300 observations\n  by = \"id\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 275 × 7\n     id species island    flipper_length_mm body_mass_g sex    year \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr>\n1     1 Adelie  Torgersen               181        3750 male   2007 \n2     2 Adelie  Torgersen               186        3800 female 2007 \n3     4 Adelie  Torgersen               193        3450 female 2007 \n4     5 Adelie  Torgersen               190        3650 male   2007 \n5     6 Adelie  Torgersen               181        3625 female 2007 \n# ℹ 270 more rows\n```\n:::\n:::\n\n\nSemi joins are underused (!) operations to filter datasets.\n\n### Anti join with `anti_join`\n\nKeep every observation in x that is not in y (@fig-rtidyverse-antijoin).\n\n![Graphical representation of anti join operation. Two tables with a shared first column (A B C, and A B D respectively) are merged together to have only columns A B C, and of that only row 3 of the first table. Only row three is retained from the first table as this is the only unique row present only in the first table.](assets/images/chapters/r-tidyverse/anti_join.png){height=150px #fig-rtidyverse-antijoin} \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::anti_join(\n  x = peng,  # 300 observations\n  y = bills, # 300 observations\n  by = \"id\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 25 × 7\n     id species island    flipper_length_mm body_mass_g sex    year \n  <int> <chr>   <chr>                 <dbl>       <dbl> <chr>  <chr>\n1    22 Adelie  Biscoe                  183        3550 male   2007 \n2    34 Adelie  Dream                   181        3300 female 2007 \n3    74 Adelie  Torgersen               195        4000 male   2008 \n4    92 Adelie  Dream                   196        4350 male   2008 \n5    99 Adelie  Biscoe                  193        2925 female 2009 \n# ℹ 20 more rows\n```\n:::\n:::\n\n\nAnti joins allow to quickly determine what information is missing in a dataset compared to an other one.\n\n### Exercise \n\nConsider the following additional dataset with my opinions on cars with a specific number of gears:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngear_opinions <- tibble::tibble(\n  gear = c(3, 5),\n  opinion = c(\"boring\", \"wow\")\n)\n```\n:::\n\n\n1. Add my opinions about gears to the `mtcars` dataset\n\n\n::: {.cell}\n\n:::\n\n\n2. Remove all cars from the dataset for which I do not have an opinion\n\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip title=\"Possible solutions\" collapse=true}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::left_join(mtcars, gear_opinions, by = \"gear\") %>%\n    tibble::as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 32 × 12\n    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb opinion\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <chr>  \n1  21       6   160   110  3.9   2.62  16.5     0     1     4     4 <NA>   \n2  21       6   160   110  3.9   2.88  17.0     0     1     4     4 <NA>   \n3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1 <NA>   \n4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1 boring \n5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2 boring \n# ℹ 27 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::anti_join(mtcars, gear_opinions, by = \"gear\") %>%\n    tibble::as_tibble()\n```\n\n::: {.cell-output .cell-output-stdout}\n```{style='border: 1px; border-style: solid; margin-left: 10px; margin-right: 10px;'}\n# A tibble: 12 × 11\n    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n4  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n5  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n# ℹ 7 more rows\n```\n:::\n:::\n\n\n:::\n\n## (Optional) clean-up\n\nLet's clean up your working directory by removing all the data and output from this chapter.\n\nWhen closing `rstudio`, say no to saving any additional files.\n\nThe command below will remove the `/<PATH>/<TO>/r-tidyverse` directory **as well as all of its contents**. \n\n:::{.callout-tip}\n## Pro Tip\nAlways be VERY careful when using `rm -r`. Check 3x that the path you are\nspecifying is exactly what you want to delete and nothing more before pressing\nENTER!\n:::\n\n```bash\nrm -r /<PATH>/<TO>/r-tidyverse\n```\n\nOnce deleted you can move elsewhere (e.g. `cd ~`).\n\nWe can also get out of the `conda` environment with\n\n```bash\nconda deactivate\n```\n\n## References\n\n::: {#refs}\n:::",
    "supporting": [
      "r-tidyverse_files/figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}