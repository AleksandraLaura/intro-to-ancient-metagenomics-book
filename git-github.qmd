---
title: Introduction to Git(Hub)
author: Megan Michel, James Fellows Yates
---

::: {.callout-tip}
For this chapter's exercises, if not already performed, you will need to create the [conda environment](before-you-start.qmd#creating-a-conda-environment) from the `yml` file in the following [link](https://github.com/SPAAM-community/intro-to-ancient-metagenomics-book/raw/main/assets/envs/git-github.yml) (right click and save as to download), and once created, activate the environment with:

```bash
conda activate git-github
```
:::

## Introduction

In this walkthrough, we will introduce the version control system **Git** as well as **Github**, a remote hosting service for version controlled repositories. Git and Github are increasingly popular tools for tracking data, collaborating on research projects, and sharing data and code, and learning to use them will help in many aspects of your own research. For more information on the benefits of using version control systems, see the slides.

## Background

What is a version control system? This is a general term for tools that allow you to track changes to objects - in this case files - over time. 
When it comes to bioinformatics, this is typically files such as scripts or notebooks, or simple text files such as CSV and FASTAs (although it can also apply to much larger binary files!). 
The use of a good version control system allows the restoration of old versions, modification to previous changes, tracking contributions by multiple people etc.
By far the most popular version control system in bioinformatics is [git](https://git-scm.com/) - which was in fact also originally co-written by the creator of the Linux operating system!

Nowadays it is popular to include a remote hosting service for your version-controlled repositories.
In bioinformatics, the most popular remote hosting service for Git version controlled code repositories is [GitHub](https://github.com). 
While other open-source alternatives exist (e.g. [GitLab](https://gitlab.com) or [BitBucket](htttps://bitbucket.org)), the most popular in bioinformatics is GitHub.
It provides a user-friendly GUI and a range of other useful tools and functionality, in addition to most bioinformatic code and tools are hosted there.

So why should you use a version control system, such as GitHub?

1. To have a (deep) backup of your work
2. Allow you to revert to old versions/modify previous changes to files
3. Allow multiple contributors to work simultaneously
4. Allow you to test new scripts or code before updating a public version in a 'sandbox' area of the repository
5. Help share your data, code, and results with the world!

## Basic workflow

The basic concepts of using git and GitHub are as shown in (@fig-git-github-workflowdiagram)

![Overview of basic operations when using git, and the pushing to a remote host such as GitHub. See chapter text for description of image. Reconstructed and modified after S. Chacon, B. Straub, Pro Git (Apress, Second Edition., 2022), The Expertâ€™s Voice.](assets/images/chapters/git-github/git-workflow.png){#fig-git-github-workflowdiagram}

In the diagram of @fig-git-github-workflowdiagram, the two dark gray boxes represent a local machine (e.g. a laptop) and a remote server. 
Within the local machine, an 'untracked' box represent files not indexed by the local git repository. 
The arrow pointing into a light grey box (the local repository) in which three white boxes are present. 
These represent different 'stages' of an object of the repository. 
This first arrow from the 'untracked' box then spans to the furthest box called 'staged', which is the operation when you add a file to be indexed by the repository (this only happens once). 
Once staged, the arrow pointing from the 'staged' box back to the first box or 'status' within the local repository, called 'unmodified'. 
This arrow represents making a 'commit' (i.e. recording to git history a repository change).
You can imagine commiting to be equivalent to a permanent(!) save.   
The next arrow represents an edit to a file, which spans the 'unmodified' box to the middle 'modified' status.
Once all edits have been made, the edited file is 'staged' - the arrow that goes from the middle of the 'modified' state to the 'staged' state - after which a commit again would be made to record that file as 'unmodified' compared to the change history. 
The arrow pointing from the local repository back to the furthest left 'untracked' state of the local repository represents the removal of the file from indexing/tracking in the git history.
Finally the two arrows that span between the local machine and remote server - one going from the local repository to the a remote repository (on the server) - represent 'pushing' the commit history to the server, and in the reverse direction - 'pulling' the commit history back to the local repository. 
These can be imagined as backing-up your git history to a cloud server, and the retrieving the backup (albeit with changes from others)

## Preparation

We will now practise some of the git operations described above.

However, before we do this, we need to set up your GitHub account so that you can communicate via the command line.

GitHub does not allow pushing and pulling with normal passwords, but rather with a concept called 'ssh keys'.
These are special cryptographic strings of characters and numbers.
When generating a pair, you get both a 'private' and 'public' key.
The former you keep privately, whereas the other you upload to other servers/people.
When you want to 'prove' that it's you sending changes to the repository, you securely send your private key and this gets compared with your public key on the remote server.
If after some cryptographic maths magic they match, the server will trust you and will accept your changes.

## Creating ssh keys

So, to begin, you will set up an SSH key to facilitate easier authentication when transferring data between local and remote repositories.
In other words, follow this section of the tutorial so that you never have to type in your github password again!

First, generate you can generate your own ssh key pair, replacing the email below with your own address.

```bash
ssh-keygen -t ed25519 -C "<YOUR_EMAIL>@<EXAMPLE>.com"
```

::: {.callout-note}
The `-t` flag tells the command which cryptographic algorithm to use.
:::

When you type this command, you will be asked a range of questions:

1. Enter file which to save key: here we suggest keep as default
2. Enter passphrase: don't specify one here (unless you want to be _ultra_ secure), just press enter
3. Enter same passphrase again: same as 2 (i.e., recommended - just press enter without any password)

You should now (hopefully!) have generated an ssh key.
This is normally indicated by a 'randomart image' being pasted to console.

To check that it worked, we can change into the default directory where keys are stored.
Run the following commands to list the files containing your public and private keys and check that the ssh program is running.

```bash
cd ~/.ssh/
ls id*
eval "$(ssh-agent -s)"
```

Now you need to give ssh your key to record:

```bash
ssh-add ~/.ssh/id_ed25519
```

## Registering keys on GitHub

Next, open your webbrowser and navigate to your github account. Go to settings -> SSH & GPG Keys -> New SSH Key. 

Here, give you key a title, and then paste the _public_ key into the main text box that you just generated on your local machine - i.e., the _whole_ string (starting `ssh-ed` and ending in your email address) when you run the following command:

```bash
cat ~/.ssh/id_ed25519.pub
```

Finally, press Add SSH key. To check that it worked, run the following command on your local machine. You should see a message telling you that you've successfully authenticated.

```bash
ssh -T git@github.com
```

For more information about setting up the SSH key, including instructions for different operating systems, check out github's documentation: [https://docs.github.com/es/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent](https://docs.github.com/es/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent).

## The only 6 commands you really need to know

Now that you have set up your own SSH key, we can begin working on some version controlled data! Navigate to your github homepage and create a new repository. You can choose any name for your new repo (including the default). Add a README file, then select Create Repository.

![Example GitHub Interface for creating a new repository, showing owner, empty respoitory name box, radio boxes indicating whether the repository should be Public or Private](assets/images/chapters/git-github/create_repo.png)
<!-- TODO -->
<!-- alt text/captions for all images-->

:::  {.callout-note}
For the remainder of the session, replace the name of my repository (vigilant-octo-journey) with your own repo name.
:::
<!-- TODO -->
<!-- replace all 'notes' with call outs -->

Change into the directory where you would like to work, and let's get started!
First, we will learn to **clone** a remote repository onto your local machine. Navigate to your new repo, select the _Code_ dropdown menu, select SSH, and copy the address as shown below.

![](assets/images/chapters/git-github/git_clone.png)

Back at your command line, clone the repo as follows:

```bash
git clone git@github.com:meganemichel/vigilant-octo-journey.git
```

Next, let's **add** a new or modified file to our 'staging area' on our local machine.

```bash
cd vigilant-octo-journey
echo "test_file" > file_A.txt
echo "Just an example repo" >> README.md
git add file_A.txt
```

Now we can check what files have been locally changed, staged, etc. with **status**.

```bash
git status
```

You should see that `file_A.txt` is staged to be committed, but `README.md` is NOT. Try adding `README.md` and check the status again.

Now we need to package or save the changes into a **commit** with a message describing the changes we've made. Each commit comes with a unique hash ID and will be stored forever in git history.

```bash
git commit -m "Add example file"
```

Finally, let's **push** our local commit back to our remote repository.

```bash
git push
```

What if we want to download new commits from our remote to our local repository?

```bash
git pull
```

You should see that your repository is already up-to-date, since we have not made new changes to the remote repo. Let's try making a change to the remote repository's README file (as below). Then, back on the command line, pull the repository again.

![](assets/images/chapters/git-github/git_pull.png)

## Working collaboratively

Github facilitates simultaneous work by small teams through branching, which generates a copy of the main repository within the repository. This can be edited without breaking the 'master' version.
First, back on github, make a new branch of your repository.

![](assets/images/chapters/git-github/git_switch.png)

From the command line, you can create a new branch as follows:

```bash
git switch -c new_branch
```

To switch back to the main branch, use

```bash
git switch main
```

Note that you **must commit changes** for them to be saved to the desired branch!

## Pull requests

A **Pull request** (aka PR) is used to propose changes to a branch from another branch. Others can comment and make suggestinos before your changes are merged into the main branch.
For more information on creating a pull request, see github's documentation: [https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request](https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/creating-a-pull-request).

## Questions to think about

1. Why is using a version control software for tracking data and code important?
2. How can using Git(Hub) help me to collaborate on group projects?
